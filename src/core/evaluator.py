import logging
import time
import importlib.util
import sys
import traceback
from typing import Dict, List, Any, Optional, Tuple, Union
import os
import tempfile

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CodeEvaluator:
    """Class responsible for evaluating code solutions generated by models"""
    
    def __init__(self, timeout: int = 10):
        """
        Initialize the evaluator
        Args:
            timeout: Maximum execution time in seconds
        """
        self.timeout = timeout
        
    def evaluate_solution(self, code: str, test_cases: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Evaluate a solution against test cases
        Args:
            code: The Python code solution as string
            test_cases: List of test cases with inputs and expected outputs
        Returns:
            Dictionary with evaluation results
        """
        try:
            # Create temp file for the code
            with tempfile.NamedTemporaryFile(suffix='.py', delete=False, mode='w+') as f:
                f.write(code)
                temp_file = f.name
                
            # Import the module
            try:
                module_name = os.path.basename(temp_file).replace('.py', '')
                spec = importlib.util.spec_from_file_location(module_name, temp_file)
                if spec is None or spec.loader is None:
                    return {
                        "success": False,
                        "error": "Failed to load module specification",
                        "test_results": []
                    }
                    
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module
                spec.loader.exec_module(module)
                
                # Try to identify the main function
                main_function = self._find_main_function(module)
                
                if not main_function:
                    return {
                        "success": False,
                        "error": "Could not identify main function in solution",
                        "test_results": []
                    }
                
                # Run test cases
                test_results = self._run_test_cases(main_function, test_cases)
                
                # Evaluate overall success
                success = all(result["passed"] for result in test_results)
                
                return {
                    "success": success,
                    "test_results": test_results,
                    "error": None,
                    "test_coverage": f"{sum(1 for r in test_results if r['passed'])}/{len(test_results)}"
                }
            
            except Exception as e:
                logger.error(f"Error evaluating solution: {str(e)}")
                logger.error(traceback.format_exc())
                return {
                    "success": False,
                    "error": str(e),
                    "test_results": []
                }
            finally:
                # Clean up temp file
                try:
                    os.unlink(temp_file)
                except:
                    pass
                
        except Exception as e:
            logger.error(f"Error in evaluation process: {str(e)}")
            return {
                "success": False,
                "error": f"Evaluation error: {str(e)}",
                "test_results": []
            }
    
    def _find_main_function(self, module) -> Optional[callable]:
        """Try to identify the main function in the solution"""
        # Check for is_prime function for prime test problem
        if hasattr(module, 'is_prime'):
            return module.is_prime
            
        # Check for check_prime function for prime test problem
        if hasattr(module, 'check_prime'):
            return module.check_prime
        
        # General approach: find functions that aren't built-ins or private
        potential_functions = [
            getattr(module, name) 
            for name in dir(module) 
            if callable(getattr(module, name)) and not name.startswith('_')
        ]
        
        # Filter out imported functions
        solution_functions = [
            func for func in potential_functions 
            if func.__module__ == module.__name__
        ]
        
        if solution_functions:
            # Return the first function found
            return solution_functions[0]
            
        return None
    
    def _run_test_cases(self, function: callable, test_cases: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Run function against test cases"""
        results = []
        
        for i, test_case in enumerate(test_cases):
            start_time = time.time()
            
            try:
                # Handle different input formats
                if isinstance(test_case["input"], list):
                    # Multiple arguments
                    actual_output = function(*test_case["input"])
                else:
                    # Single argument
                    actual_output = function(test_case["input"])
                
                execution_time = time.time() - start_time
                
                # Check if result matches expected output
                passed = actual_output == test_case["expected"]
                
                results.append({
                    "test_case_id": i + 1,
                    "input": test_case["input"],
                    "expected": test_case["expected"],
                    "actual": actual_output,
                    "passed": passed,
                    "execution_time": execution_time
                })
            
            except Exception as e:
                results.append({
                    "test_case_id": i + 1,
                    "input": test_case["input"],
                    "expected": test_case["expected"],
                    "actual": f"Error: {str(e)}",
                    "passed": False,
                    "execution_time": time.time() - start_time
                })
                
        return results